<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wave Lab: Ultimate Physics Edition</title>
<style>
  body, html { margin: 0; padding: 0; height: 100%; font-family: sans-serif; background: #f0f2f5; overflow: hidden; }
  #app { display: flex; flex-direction: column; height: 100vh; }
  #header { text-align: center; padding: 10px; background: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 10; }
  #main { flex: 1; display: flex; padding: 15px; gap: 15px; box-sizing: border-box; height: calc(100vh - 60px); overflow: hidden; }
  
  #controls { 
    width: 280px; background: white; padding: 20px; border-radius: 12px; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; 
    gap: 4px; overflow-y: auto; max-height: 100%; scrollbar-width: thin; 
  }
  #controls::-webkit-scrollbar { width: 6px; }
  #controls::-webkit-scrollbar-thumb { background: #ccc; border-radius: 10px; }

  #controls label { font-size: 11px; font-weight: bold; color: #555; text-transform: uppercase; margin-top: 6px; }
  #controls input[type="range"] { width: 100%; cursor: pointer; }
  #controls button { width: 100%; padding: 10px; border: none; border-radius: 6px; background: #007bff; color: white; font-weight: bold; cursor: pointer; margin-top: 5px; flex-shrink: 0; }
  #controls button:hover { background: #0056b3; }
  
  .checkbox-container { display: flex; align-items: center; gap: 8px; margin: 8px 0; font-size: 12px; font-weight: bold; color: #333; flex-shrink: 0; }
  
  #simContainer { flex: 1; background: #fff; border-radius: 12px; overflow: hidden; position: relative; border: 1px solid #ddd; }
</style>
</head>
<body>

<div id="app">
  <div id="header"><h2>Wave Lab: Virtual Physics Lab</h2></div>
  <div id="main">
    <div id="controls">
      <button id="viewBtn">Switch to Lines View</button>
      <button id="modeBtn">Standing Wave</button>
      <button id="waveTypeBtn">Switch to Longitudinal</button>
      <button id="interferenceBtn" style="background:#28a745;">Enable Interference</button>
      
      <div class="checkbox-container">
        <input type="checkbox" id="colorToggle" checked>
        <label for="colorToggle">Enable Color</label>
      </div>
      <div class="checkbox-container">
        <input type="checkbox" id="gridToggle">
        <label for="gridToggle">Show Grid Lines</label>
      </div>
      <div class="checkbox-container">
        <input type="checkbox" id="refToggle" checked>
        <label for="refToggle">Show Reference Point</label>
      </div>

      <label>Amplitude</label>
      <input type="range" id="amp" min="0" max="0.8" step="0.01" value="0.4">
      <label>Frequency</label>
      <input type="range" id="freq" min="0.5" max="5" step="0.1" value="1.5">
      <label>Wavelength</label>
      <input type="range" id="lambda" min="0.5" max="5" step="0.1" value="2.5">
      <label>Slow Motion (Speed)</label>
      <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1">
      <label>Particle Density</label>
      <input type="range" id="density" min="20" max="250" step="1" value="100">
      
      <button id="pauseBtn" style="background:#dc3545; margin-top:15px;">Pause / Play</button>
      <button id="resetBtn" style="background:#6c757d;">Reset Animation</button>
    </div>
    <div id="simContainer"></div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const container = document.getElementById("simContainer");
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

let paused = false, timeScale = 1.0, totalElapsed = 0;
const clock = new THREE.Clock();

const uniforms = {
  uTime: { value: 0 },
  uAmp: { value: 0.4 },
  uFreq: { value: 1.5 },
  uLambda: { value: 2.5 },
  uStanding: { value: 0.0 },
  uLongitudinal: { value: 0.0 },
  uIsLine: { value: 0.0 },
  uUseColor: { value: 1.0 },
  uShowGrid: { value: 0.0 },
  uShowRef: { value: 1.0 },
  uInterference: { value: 0.0 },
  uDensity: { value: 100.0 },
  uResolution: { value: new THREE.Vector2(container.clientWidth, container.clientHeight) }
};

const material = new THREE.ShaderMaterial({
  uniforms: uniforms,
  vertexShader: `
    varying vec2 vUv;
    void main() { vUv = uv; gl_Position = vec4(position, 1.0); }
  `,
  fragmentShader: `
    uniform float uTime, uAmp, uFreq, uLambda, uStanding, uLongitudinal, uIsLine, uDensity, uUseColor, uShowGrid, uShowRef, uInterference;
    uniform vec2 uResolution;
    varying vec2 vUv;

    float drawCircle(vec2 uv, vec2 center, float radius) {
      return smoothstep(radius, radius - (2.0 / uResolution.y), length(uv - center));
    }

    float drawLine(vec2 uv, float xPos, float yCenter, float height) {
      float thickness = 2.0 / uResolution.x;
      if(abs(uv.x - xPos) < thickness && abs(uv.y - yCenter) < height) return 1.0;
      return 0.0;
    }

    void main() {
      vec2 uv = (vUv * 2.0 - 1.0);
      float aspect = uResolution.x / uResolution.y;
      uv.x *= aspect;

      vec3 finalColor = vec3(1.0); 

      // Draw Grid Lines
      if(uShowGrid > 0.5) {    
          float thickness = 0.01;
          float step = 0.1;    
          float nearestGridX = round(uv.x / step) * step;    //uv থেকে nearest Grid Line নির্ণয় 
          float nearestGridY = round(uv.y / step) * step;
          float gridX = smoothstep(thickness, 0.0, abs(uv.x - nearestGridX)) * 0.1;
          float gridY = smoothstep(thickness, 0.0, abs(uv.y - nearestGridY)) * 0.1;
          finalColor -= (gridX + gridY);
      }

      float maxDisp = (uInterference > 0.5) ? (uAmp * 2.0 + 0.25) : (uAmp + 0.25);
      if(uLongitudinal > 0.5){
          if(uv.y < -0.5 || uv.y > 0.5) { gl_FragColor = vec4(finalColor, 1.0); return; } 
      } else {
          if(uv.y < -maxDisp || uv.y > maxDisp) { gl_FragColor = vec4(finalColor, 1.0); return; } 
      }

      float k = 6.28318 / uLambda;
      float omega = 6.28318 * uFreq;
      float v = omega / k; 
      float startX = -1.2 * aspect;
      float endX = 1.2 * aspect;
      float stepSize = (endX - startX) / uDensity; 

      for(float n = 0.0; n <= 200.0; n++) {
        if (n > uDensity) break;
        float x0 = startX + (n * stepSize);
        float disp = 0.0;
        
        
        if(uStanding > 0.5) {
          disp = uAmp * sin(k * x0) * cos(omega * uTime);
        } else {
          float waveFront = v * uTime;
          float dist = x0 - startX; 
          if(waveFront > dist) disp = uAmp * sin(k * (waveFront - dist));
          
          // Interference হলে ডান দিক থেকে আসা তরঙ্গের জন্য disp যোগ করতে হবে। 
          if(uInterference > 0.5) {
              float dist2 = endX - x0;  //ডান দিক থেকে আসা তরঙ্গ সেই particle এ পৌছাতে যে দূরত্ব অতিক্রম করে। 
              if(waveFront > dist2) disp += uAmp * sin(k * (waveFront - dist2));
          }
        }

        bool isRef = (abs(n - uDensity/2.0) < 0.6) && (uShowRef > 0.5);
        vec3 waveCol = (uUseColor > 0.5) ? mix(vec3(0.0, 0.3, 0.9), vec3(1.0, 0.1, 0.1), abs(disp/max(maxDisp, 0.01))) : vec3(0.0);
        if(isRef) waveCol = vec4(1.0, 0.0, 0.0, 1.0).rgb;

        if(uIsLine > 0.5) {
          float lX = (uLongitudinal > 0.5) ? x0 + disp : x0;
          float lY = (uLongitudinal > 0.5) ? 0.0 : disp;
          float l = drawLine(uv, lX, lY, 0.25);
          if(l > 0.5) finalColor = mix(finalColor, waveCol, l);
        } else {
          float rows = (uLongitudinal > 0.5) ? 5.0 : 1.0;
          for(float r = 0.0; r < 5.0; r++) {
             if(r >= rows) break;
             float yOffset = (r - (rows - 1.0) * 0.5) * 0.2;
             vec2 pPos = (uLongitudinal > 0.5) ? vec2(x0 + disp, yOffset) : vec2(x0, yOffset + disp);
             float cSize = isRef ? 0.035 : 0.022;
             float c = drawCircle(uv, pPos, cSize);
             if(c > 0.5) finalColor = mix(finalColor, waveCol, c);
          }
        }
      }
      gl_FragColor = vec4(finalColor, 1.0);
    }
  `
});

const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
scene.add(mesh);

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if(!paused) { totalElapsed += delta * timeScale; uniforms.uTime.value = totalElapsed; }
  renderer.render(scene, camera);
}
animate();

// UI Bindlers
document.getElementById("colorToggle").onchange = e => uniforms.uUseColor.value = e.target.checked ? 1.0 : 0.0;
document.getElementById("gridToggle").onchange = e => uniforms.uShowGrid.value = e.target.checked ? 1.0 : 0.0;
document.getElementById("refToggle").onchange = e => uniforms.uShowRef.value = e.target.checked ? 1.0 : 0.0;
document.getElementById("viewBtn").onclick = e => {
  uniforms.uIsLine.value = 1.0 - uniforms.uIsLine.value;
  e.target.innerText = uniforms.uIsLine.value > 0.5 ? "Switch to Particles View" : "Switch to Lines View";
};
document.getElementById("modeBtn").onclick = e => {
  uniforms.uStanding.value = 1.0 - uniforms.uStanding.value;
  e.target.innerText = uniforms.uStanding.value > 0.5 ? "Travelling Wave" : "Standing Wave";
};
document.getElementById("interferenceBtn").onclick = e => {
  uniforms.uInterference.value = 1.0 - uniforms.uInterference.value;
  e.target.innerText = uniforms.uInterference.value > 0.5 ? "Disable Interference" : "Enable Interference";
  e.target.style.background = uniforms.uInterference.value > 0.5 ? "#6c757d" : "#28a745";
};
document.getElementById("waveTypeBtn").onclick = e => {
  uniforms.uLongitudinal.value = 1.0 - uniforms.uLongitudinal.value;
  e.target.innerText = uniforms.uLongitudinal.value > 0.5 ? "Switch to Transverse" : "Switch to Longitudinal";
};
document.getElementById("amp").oninput = e => uniforms.uAmp.value = parseFloat(e.target.value);
document.getElementById("freq").oninput = e => uniforms.uFreq.value = parseFloat(e.target.value);
document.getElementById("lambda").oninput = e => uniforms.uLambda.value = parseFloat(e.target.value);
document.getElementById("speed").oninput = e => timeScale = parseFloat(e.target.value);
document.getElementById("density").oninput = e => uniforms.uDensity.value = parseFloat(e.target.value);
document.getElementById("pauseBtn").onclick = () => paused = !paused;
document.getElementById("resetBtn").onclick = () => { totalElapsed = 0; uniforms.uTime.value = 0; };

window.onresize = () => {
  renderer.setSize(container.clientWidth, container.clientHeight);
  uniforms.uResolution.value.set(container.clientWidth, container.clientHeight);
};
</script>
</body>
</html>
